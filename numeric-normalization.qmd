# Normalization {#sec-normalization}

Normalization is a method where we modify a variable by subtracting the mean and dividing by the standard deviation

$$X_{scaled} = \dfrac{X - \text{mean}(X)}{\text{sd}(X)}$$

Performing this transformation means that the resulting variable will have a mean of 0 and a standard deviation and variance of 1. It is a common misconception that this transformation is done to make the data normally distributed. This transformation doesn't change the distribution, it scales the values. Below is a figure @fig-normalization-not-normal that illustrate that point

```{r}
#| label: fig-normalization-not-normal
#| echo: false
#| message: false
#| fig-cap: |
#|   Normalization doesn't make data more normal. Green curve indicates density of unit normal
#|   distribution. 
#| fig-alt: |
#|   2 histograms of distribution one above the other. The top distribution shows a bimodal
#|   distribution. Below is the same distribution after being normalized. Both appear clearly
#|   non-normally distributed. Green curve is overlaid lower histogram. It doesn't follow.
library(ggplot2)
library(dplyr)
library(tidyr)
set.seed(1234)

plotting_data <- tibble(Original = (rbeta(1000, 0.3, 0.5) + rnorm(1000, sd = 0.05)) * 10) %>%
  mutate(Transformed = (Original - mean(Original)) / sd(Original)) %>%
  pivot_longer(everything())

norm_curve <- tibble(
  x = seq(min(plotting_data$value) - 1, max(plotting_data$value), by = 0.2),
  y = dnorm(seq(min(plotting_data$value) - 1, max(plotting_data$value), by = 0.2)),
  name = "Transformed"
) %>%
  mutate(y = 1000 / sum(y) * y)

plotting_data %>%
  ggplot(aes(value)) +
  geom_histogram(binwidth = 0.2) +
  facet_grid(name~., scales = "free_y") +
  theme_minimal() +
  labs(x = NULL, y = NULL) +
  geom_line(aes(x, y), data = norm_curve, color = "green4")
```

In @fig-normalization-not-normal we see some distribution, before and after applying normalization to it. Both the original and transformed distribution are clearly bimodal, and the transformed distribution is no more normal than the original. And that is fine, because the transformation did its job by moving the values close to 0 and and a specific spread, which in this case is a variance of 1.

## Pros and Cons

### Pros

-   If you don't have any severe outliers then you will rarely see any downsides to applying normalization

-   Fast calculations

-   Transformation can easily be reversed, making it interpretations easier on the original scale

### Cons

-   Not all software solutions will not be helpful when applying this transformation to a constant variable. A division by 0 error is likely what you will see
-   This transformation is highly affected by outliers, as they affect the mean and standard deviation quite a lot.

Below in the figure @fig-normalization-outlier Is an illustration of the effect by having a single high values. In this case a single observation with the value `10000` moved the transformed distribution much more tight around zero. And all but removed the variance of the non-outliers.

```{r}
#| label: fig-normalization-outlier
#| echo: false
#| message: false
#| fig-cap: |
#|   Outliers can have a big effect of the resulting distribution when applying normalization.
#| fig-alt: |
#|   4 histograms of distribution in 2 columns. The top distribution shows the same bimodal
#|   distribution. Below are the same distributions after being normalized. The right column
#|   shows the effect of having one outlier at 10000, which in this case made the transformed
#|   distribution about a fifth of the width.
library(ggplot2)
library(dplyr)
library(tidyr)
set.seed(1234)

rand_val <- (rbeta(1000, 0.3, 0.5) + rnorm(1000, sd = 0.05)) * 10

plotting_data <- 
  bind_rows(
    tibble(Original = rand_val) %>%
      mutate(Transformed = (Original - mean(Original)) / sd(Original)) %>%
      pivot_longer(everything()) %>%
      mutate(outlier = "No outlier"),
    tibble(Original = c(rand_val, 500)) %>%
      mutate(Transformed = (Original - mean(Original)) / sd(Original)) %>%
      pivot_longer(everything()) %>%
      mutate(outlier = "One outlier at 10000")
  ) %>%
  filter(value < 15)
  
plotting_data %>%
  ggplot(aes(value)) +
  geom_histogram(binwidth = 0.2) +
  facet_grid(name ~ outlier, scales = "free") +
  theme_minimal() +
  labs(x = NULL, y = NULL)
```

## R Examples

## Python Examples
