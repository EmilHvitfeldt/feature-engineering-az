# Advanced features {#sec-datetime-advanced}

```{r}
#| echo: false
#| message: false
library(tidyverse)
```


All the features we were able to extract were related to what day or time it was for an given observation. Or numbers on the form "how many since start of month" or "how many days since start of week". And while this information can be useful, there will often be times where we want to do slight modifications that can result in huge payoff.

Consider merchandise sale related data. The mere indication of a specific dates might become useful, but the sale amount is not likely to be affected just on the sale days, but on the surrounding days as well. Consider the American Black Friday. This day is predetermined to come every year at a easily recognized day, namely the last Friday of November. Considering its close time to Christmas other gift-giving holidays, it is a common day for thrifty people to start buying presents.

In the extraction sense we have a single indicator for the day of Black Friday

```{r}
tibble(
  day = as_date("2023-11-24") + c(-5:5),
  black_friday = c(rep(0, 5), 1, rep(0, 5))
) |>
  ggplot(aes(day, black_friday)) +
  geom_col() +
  theme_minimal()
```

But it would make sense that since we know the day of Black Friday, that the sales will see a drop on the previous days, we can incorporate that as well.

```{r}
tibble(
  day = as_date("2023-11-24") + c(-5:5),
  black_friday = c(-0.5 ^ (5:1), 1, rep(0, 5))
) |>
  ggplot(aes(day, black_friday)) +
  geom_col() +
  theme_minimal()
```

On the other hand, once the sale has started happening for the sales to pick up again. Since this is the last big sale before the Holidays, shoppers are free to buy their remaining presents as they don't have to fear of the item going on sale.

```{r}
tibble(
  day = as_date("2023-11-24") + c(-5:5),
  black_friday = c(-0.5 ^ (5:1), 1, 0.25 ^ (1:5/2))
) |>
  ggplot(aes(day, black_friday)) +
  geom_col() +
  theme_minimal()
```

The exact effects shown here are just approximate to our story at hand. But they provide a useful illustration. There are a lot of bandwidth to be given if we look at date times from a distance perspective. 
We can play around with "distance from" and "distance to", different numerical transformations we saw in @sec-numeric, signs and indicators we talked about in @sec-datetime-extraction to tailor our feature engineering to our problem.

What all these methods have in common is a reference point. For an extracted `day` feature, the reference point is "first of month" and the **after**-function is `x`, or in other words "days since time of day". We see this in the following chart. Almost all extracted functions follow this formula

```{r}
tibble(
  date = as_date("2023-11-24") + seq(-90, 0)
) |>
  mutate(day = day(date)) |>
  ggplot(aes(date, day)) +
  geom_col() +
  theme_minimal()
```

we could just as well do the inverse and look at how many days are left in the month. This would have a **before**-function of `x` as well.

```{r}
tibble(
  date = as_date("2023-11-24") + seq(-90, 0)
) |>
  mutate(day = day(date)) |>
  mutate(month = month(date)) |>
  mutate(day = max(day) - day + 1, .by = month) |>
  ggplot(aes(date, day)) +
  geom_col() +
  theme_minimal()
```

We can do a both-sided formula by looking at "how many days are we away from a weekend". This would have both the before and after functions be `x` and look like so. Here it isn't too interesting as it is quite periodic, but using the same measure with "sale" instead of "weekend" and suddenly you have something different.

```{r}
tibble(
  date = as_date("2023-11-24") + seq(-90, 0)
) |>
  mutate(day = c(1, 2, 3, 2, 1, 0, 0)[wday(date)]) |>
  ggplot(aes(date, day)) +
  geom_col() +
  theme_minimal()
```

There are many other functions you can use, they will depend entirely on your task at hand. A few examples are shown below for inspiration.

```{r}
tibble(
  date = as_date("2023-11-24") + seq(-90, 0)
) |>
  mutate(day = day(date)) |>
  mutate(`log(x)` = log(day)) |>
  mutate(`x^2` = day ^ 2) |>
  mutate(`pmin(day, 10)` = pmin(day, 10)) |>
  rename(x = day) |>
  pivot_longer(-date) |>
  ggplot(aes(date, value)) +
  geom_col() +
  facet_wrap(~name, scales = "free_y") +
  theme_minimal() 
```

What makes these calculations so neat is that they can be tailored to our task at hand, and that they work with irregular events such as holidays and signup dates. These methods are not circular by definition, but they will work in many ways like it. We will cover explicit circular methods in @sec-datetime-circular.

## Pros and Cons

### Pros

### Cons

## R Examples

## Python Examples

