# Frequency Encoding {#sec-frequency-encoding}

Frequency encoding takes a categorical variable and replaces each level with its frequency in the training data set. This results in a single numeric variable, with values between 0 and 1. This is a trained method since we need to keep a record of the frequencies from the training data set.

This method isn't a silver bullet, as it will only sometimes be useful. It is useful when the frequency/rarity of a category level is related to our outcome. Imagine we have data about wines and their producers, some big producers produce many wines, and small producers that only produce a couple. This information could potentially be useful and would be easily captured in frequency encoding. This method is not able to distinguish between two levels that have the same frequency.

Unseen levels can be automatically handled by giving them a value of 0 as they are unseen in the training data set. Thus no extra treatment is neasesary. Sometimes taking the logarithm can be useful if you are having a big difference between the number of occurrences in your levels.

::: callout-note
This is similar to **count encoding** in the sense that both these encodings calculate the same quantity, the difference is just what you put in the denominator. Since we divide by a constant value in frequency encoding, these will be treated as identical methods.
:::

## Pros and Cons

### Pros

- Powerful and simple when used correctly
- High interpretability

### Cons

- Is not able to distinguish between two levels that have the same frequency
- May not add predictive power

## R Examples

## Python Examples
