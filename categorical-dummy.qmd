# Dummy Encoding {#sec-dummy-encoding}

We have some categorical variable and we want to turn it into numerical values, one of the most common ways of going about it it so create **dummy variables**. Dummy variables are variables that only takes the values 0 and 1 to indicate the absence or presence of the levels in a categorical variable. This is nicely shown with an example.

Consider this short categorical variable of animals, we observe there are 3 unique values "cat", "dog", and "horse".

```{r}
#| echo: false
c("dog", "cat", "horse", "dog", "cat")
```

Which just this knowledge we can create the corresponding dummy variables. There should be 3 columns one for each of the levels

```{r}
#| echo: false
dummy <- matrix(0L, nrow = 5, ncol = 3)
colnames(dummy) <- c("cat", "dog", "horse")
dummy[1, 2] <- 1L
dummy[2, 1] <- 1L
dummy[3, 3] <- 1L
dummy[4, 2] <- 1L
dummy[5, 1] <- 1L
dummy
```

From this we have a couple of observations. Firstly the length of each of these variables are equal to the length of the original categorical variable. The number of columns corresponds to the number of levels. And lastly the sum of all the values on each row equals 1 since all the rows contains one 1 and the remaining 0s. This means that for even small number of levels, you get **sparse data**. Sparse data is data where there is a lot of zeroes, meaning that it it would take less space to store where the non-zero values are instead of all the values. You can read more about how and when to care about sparse data in @sec-sparse. What this means for dummy variable creating, that depending on whether your software can handle sparse data, you might need to limit the number of levels in your categorical variables. One way to do this would be to collapse levels together, which you can read about in @sec-categorical-collapse.

Dummy variable creation is a *trained* method. This means that doing the training step, the levels of each categorical variables are saved, and then these and only these values are used for dummy variable creation. If we assumed that the above example data were used to train the preprocessor, and we passed in the values `["dog", "cat", "cat", "dog"]` during future applications, we would expect the following dummy variables

```{r}
#| echo: false
dummy <- matrix(0L, nrow = 4, ncol = 3)
colnames(dummy) <- c("cat", "dog", "horse")
dummy[1, 2] <- 1L
dummy[2, 1] <- 1L
dummy[3, 1] <- 1L
dummy[4, 2] <- 1L
dummy
```

it is important that the `horse` variable is here too, even if it is empty as the subsequent preprocessing steps and model expects the horse variable to be present. Likewise you can run into problems if the value `"duck"` was used as the preprosessor wouldn't know what to do. These cases are talked about in @sec-unseen.

Explain one hot vs dummy

TODO add Diagram

## Pros and Cons

### Pros

### Cons

## R Examples

# Python Examples

TODO
