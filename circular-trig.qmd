---
pagetitle: "Feature Engineering A-Z | Trigonometric"
---

# Trigonometric {#sec-circular-trig}

::: {style="visibility: hidden; height: 0px;"}
## Trigonometric
:::

One of the most common ways of dealing with circular data is handled by applying the trigonometric funtions `sin()` and `cos()` to the circular variable. 

TODO: add formulas about offset, cycle size and frequency

I think that this is easier to see with some toy visualizations.

```{r}
library(tidyverse)
set.seed(1234)

toy_data <- tibble(
  predictor = 1:1000
) |>
  mutate(target = pmax(sin(predictor / 365 * pi * 2), 0) ^ 4 + 
                  rnorm(n(), sd = 0.1) - 0.5) |>
  arrange(target)
```

```{r}
toy_data |>
  ggplot(aes(predictor, target)) +
  geom_point()
```

```{r}
library(recipes)
recipe(target ~ predictor, toy_data) |>
    step_harmonic(predictor, cycle_size = 365, frequency = 1) |>
    prep() |>
    bake(new_data = NULL) |>
    ggplot(aes(predictor_sin_1, predictor_cos_1, color = target)) +
    geom_point() +
    scale_color_viridis_c()
```

in this simple case, the `predictor_sin_1` becomes a ideal predictor.
on the other hand, `predictor_cos_1` doesn't do as well since it doesn't allow for a clean seperation between high and low `target` values.
All the high values appears when `predictor_cos_1` is close to 0, 
but not all observations where `predictor_cos_1` is close to 0 have high target values.

Above we got lucky that we picked the right cycle size and frequency,
since we knew them, if you are off, even by a bit you can get uninformative transformations like the one below.

```{r}
library(recipes)
recipe(target ~ predictor, toy_data) |>
    step_harmonic(predictor, cycle_size = 150, frequency = 1) |>
    prep() |>
    bake(new_data = NULL) |>
    ggplot(aes(predictor_sin_1, predictor_cos_1, color = target)) +
    geom_point() +
    scale_color_viridis_c()
```

there is also the importane of the starting point.
We got lucky that that it gave 1 good predictor and one bad predictor.
Even if the frequency is good, 
but the starting point is off you end up with two decent predictors.
These two predictors are still good enough, but they are less ideal than the first example we got.

```{r}
library(recipes)
recipe(target ~ predictor, toy_data) |>
    step_harmonic(predictor, cycle_size = 365, frequency = 1, starting_val = 45) |>
    prep() |>
    bake(new_data = NULL) |>
    ggplot(aes(predictor_sin_1, predictor_cos_1, color = target)) +
    geom_point() +
    scale_color_viridis_c()
```

one of the issues with this approach is that each variable contains double information. e.i. you need both variable to detect "summer"

What do you do if there are multiple events of interest in the period? (summer and halloween)



```{r}
library(animalshelter)
library(tidyverse)

longbeach
  glimpse()
```

## Pros and Cons

### Pros

### Cons

## R Examples

## Python Examples
